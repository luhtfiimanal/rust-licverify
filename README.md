# ğŸ” licverify

<div align="center">

**Enterprise-Grade License Verification for Rust**

*Secure, fast, and reliable license validation with hardware binding and automatic expiry enforcement*

[![Crates.io](https://img.shields.io/crates/v/licverify.svg)](https://crates.io/crates/licverify)
[![Documentation](https://docs.rs/licverify/badge.svg)](https://docs.rs/licverify)
[![License: MIT](https://img.shields.io/badge/license-MIT-blue.svg)](#license)
[![CI](https://github.com/luhtfiimanal/rust-licverify/workflows/CI/badge.svg)](https://github.com/luhtfiimanal/rust-licverify/actions)

</div>

---

## âœ¨ Why licverify?

**licverify** is a Rust client for the [go-license](https://github.com/luhtfiimanal/go-license) license verification system. It provides enterprise-grade license validation with cryptographic signatures, hardware binding, and automatic expiry enforcement, fully compatible with licenses generated by the go-license ecosystem.

### ğŸ¯ **Perfect For:**
- ğŸ¢ **Enterprise Software**: Mission-critical applications requiring secure licensing
- ğŸ”¬ **Scientific Tools**: Research software with institutional licensing
- ğŸ® **Gaming**: Game engines and tools with hardware-locked licenses  
- ğŸ’¼ **SaaS Applications**: Cloud services with node-locked licensing

### âš¡ **Security That Matters**

| Feature | Benefit | Implementation |
|---------|---------|----------------|
| **ğŸ” RSA-SHA256** | Cryptographic integrity | 2048-bit RSA with SHA-256 |
| **ğŸ’» Hardware Binding** | Device-locked licensing | MAC, Disk ID, Hostname |
| **â° Auto-Expiry** | Time-based enforcement | Background monitoring |
| **ğŸ”„ Format Support** | Legacy compatibility | Binary v2.0+ & JSON v1.x |

---

## ğŸš€ Quick Start

Add this to your `Cargo.toml`:

```toml
[dependencies]
licverify = "0.1.0"
```

## Usage

### ğŸ”¥ **Basic License Verification**

```rust
use licverify::Verifier;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Load your RSA public key
    let public_key_pem = std::fs::read_to_string("public.pem")?;
    let verifier = Verifier::new(&public_key_pem)?;
    
    // Load and verify license
    let license = verifier.load_license("license.lic")?;
    
    match verifier.verify(&license) {
        Ok(()) => {
            println!("âœ… License is valid!");
            println!("ğŸ“‹ Customer: {}", license.customer_id);
            println!("ğŸ“¦ Product: {}", license.product_id);
            println!("â° Expires: {}", license.expiry_date.format("%Y-%m-%d"));
        }
        Err(e) => {
            eprintln!("âŒ License verification failed: {}", e);
            std::process::exit(1);
        }
    }
    
    Ok(())
}
```

### ğŸ–¥ï¸ **Command Line Interface**

```bash
# Install from source
git clone https://github.com/luhtfiimanal/rust-licverify
cd rust-licverify
cargo build --release

# Verify a license
./target/release/licverify --public-key public.pem --license license.lic
```

**Output:**
```
License ID: 1
Customer: BMKG
Product: Digitizer
Serial: SN12345
Issue Date: 2025-04-29 07:57:17 UTC
Expiry Date: 2026-04-29 07:57:17 UTC
Features: basic, miniseed, seedlink
Days remaining: 225
âœ… License is valid!
```

---

## ğŸ›¡ï¸ **Enterprise Features**

### ğŸ”’ **Hardware Binding Verification**
Prevent license sharing by binding to specific hardware:

```rust
use licverify::{Verifier, HardwareInfo};

let verifier = Verifier::new(&public_key_pem)?;
let license = verifier.load_license("license.lic")?;

// Check hardware binding
match verifier.verify_hardware_binding(&license) {
    Ok(()) => println!("âœ… Hardware binding valid"),
    Err(e) => println!("âŒ Hardware mismatch: {}", e),
}

// Get current hardware info
let hw_info = HardwareInfo::get()?;
println!("ğŸ–¥ï¸  MAC Addresses: {:?}", hw_info.mac_addresses);
println!("ğŸ’¾ Disk IDs: {:?}", hw_info.disk_ids);
println!("ğŸ·ï¸  Hostname: {}", hw_info.hostname);
```

#### ğŸš¨ **Basic Timer Implementation**

```rust
use licverify::{Verifier, LicenseError};
use std::time::Duration;
use std::thread;

fn start_license_monitor(verifier: Verifier, license_path: String) {
    thread::spawn(move || {
        loop {
            thread::sleep(Duration::from_secs(3600)); // Check every hour
            
            match verifier.load_license(&license_path) {
                Ok(license) => {
                    if let Err(_) = verifier.verify(&license) {
                        eprintln!"âš ï¸  License expired or invalid - terminating application");
                        std::process::exit(1);
                    }
                }
                Err(_) => {
                    eprintln!("âŒ Could not load license - terminating application");
                    std::process::exit(1);
                }
            }
        }
    });
}
```

#### ğŸ›¡ï¸ **Production-Ready License Guard**

```rust
use licverify::Verifier;
use std::sync::{Arc, atomic::{AtomicBool, Ordering}};
use std::time::Duration;
use std::thread;

pub struct LicenseGuard {
    should_shutdown: Arc<AtomicBool>,
}

impl LicenseGuard {
    pub fn new(verifier: Verifier, license_path: String, check_interval_secs: u64) -> Self {
        let should_shutdown = Arc::new(AtomicBool::new(false));
        let should_shutdown_clone = should_shutdown.clone();
        
        thread::spawn(move || {
            loop {
                thread::sleep(Duration::from_secs(check_interval_secs));
                
                match verifier.load_license(&license_path) {
                    Ok(license) => {
                        match verifier.verify(&license) {
                            Ok(()) => {
                                // Check if license expires within 7 days
                                let days_remaining = license.days_until_expiry();
                                if days_remaining <= 7 {
                                    eprintln!("âš ï¸  License expires in {} days!", days_remaining);
                                }
                            }
                            Err(_) => {
                                eprintln!("ğŸš¨ License expired - initiating graceful shutdown");
                                should_shutdown_clone.store(true, Ordering::Relaxed);
                                return;
                            }
                        }
                    }
                    Err(_) => {
                        eprintln!("âŒ License file error - initiating shutdown");
                        should_shutdown_clone.store(true, Ordering::Relaxed);
                        return;
                    }
                }
            }
        });
        
        Self { should_shutdown }
    }
    
    pub fn should_shutdown(&self) -> bool {
        self.should_shutdown.load(Ordering::Relaxed)
    }
}

// Usage in your application
fn main() {
    let verifier = Verifier::new(&public_key_pem).unwrap();
    let license_guard = LicenseGuard::new(verifier, "license.lic".to_string(), 300); // Check every 5 minutes
    
    // Your application main loop
    loop {
        if license_guard.should_shutdown() {
            println!("ğŸ›‘ License expired - shutting down gracefully");
            break;
        }
        
        // Your application logic here
        thread::sleep(Duration::from_secs(1));
    }
}
```

---

## ğŸ—ï¸ **Architecture & Compatibility**

### âœ¨ **Core Features**
- ğŸš€ **Cross-Platform**: Supports Linux, Windows, and macOS
- ğŸ” **RSA-SHA256**: 2048-bit RSA with PKCS#1 v1.5 padding
- ğŸ’» **Hardware Binding**: MAC addresses, disk IDs, and hostname verification
- ğŸ“ **Dual Format**: Binary (v2.0+) and JSON (v1.x) license support
- ğŸ–¥ï¸ **CLI Interface**: Simple command-line verification tool
- ğŸ“š **Library**: Embeddable Rust library for applications
- â° **Auto-Expiry**: Background monitoring and enforcement

### ğŸ”„ **go-license Ecosystem Compatibility**

This Rust implementation is fully compatible with the [go-license](https://github.com/luhtfiimanal/go-license) ecosystem:

| Component | Repository | Purpose |
|-----------|------------|---------|
| **ğŸ”§ License Generator** | [go-license](https://github.com/luhtfiimanal/go-license) | Create and sign licenses |
| **ğŸ Python Client** | [python-licverify](https://github.com/luhtfiimanal/python-licverify) | Python verification |
| **ğŸ¦€ Rust Client** | **rust-licverify** (this project) | Rust verification |

### ğŸ”„ **License Format Support**

| Format | Version | Features | Status |
|--------|---------|----------|--------|
| **Binary** | v2.0+ | Full feature set | âœ… Supported |
| **JSON** | v1.x | Legacy compatibility | âœ… Supported |
| **Signature** | All | RSA-2048 + SHA-256 | âœ… Verified |

---

## ğŸŒ **go-license Ecosystem**

This project is part of the broader go-license ecosystem for cross-platform license management:

- **ğŸ”§ [go-license](https://github.com/luhtfiimanal/go-license)** - Main license generator and Go client
- **ğŸ [python-licverify](https://github.com/luhtfiimanal/python-licverify)** - Python verification client  
- **ğŸ¦€ [rust-licverify](https://github.com/luhtfiimanal/rust-licverify)** - Rust verification client (this project)

All clients can verify licenses generated by the go-license system interchangeably, providing flexibility for multi-language environments.

---

## ğŸ¤ **Contributing**

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change.

### Development Setup

```bash
# Fork and clone the repository
git clone https://github.com/luhtfiimanal/rust-licverify
cd rust-licverify

# Run tests
cargo test

# Format code
cargo fmt

# Run linter
cargo clippy

# Check for security vulnerabilities
cargo audit
```

### Testing

```bash
# Run all tests
cargo test

# Run with coverage
cargo test --all-features

# Run benchmarks
cargo bench
```

### Examples

```bash
# Basic usage example
cargo run --example basic_usage

# CLI verification
./target/release/licverify --help
```
